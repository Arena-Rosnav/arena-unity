using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using RestServer.Helper;
using RestServer.WebSocket;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace RestServer {
    /// <summary>
    ///     Collection of all HTTP endpoints. Thread safe.
    /// </summary>
    public class EndpointCollection {
        #region Properties

        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();
        private readonly Dictionary<HttpMethod, List<Endpoint>> _handlers = new Dictionary<HttpMethod, List<Endpoint>>();
        private readonly Logger _logger = new Logger(Debug.unityLogger.logHandler);

        /// <summary>
        ///     Report if any newly added endpoint would be matched by any already existing endpoint. If that happens, the "first" endpoint in the collection would receive the request,
        ///     and the second endpoint handler would never be called.
        ///     This only works for non-regex endpoints.
        ///     The check can take some additional cpu cycles and can therefore be turned off. It defaults to on, if inside unity editor and off, if on production build.
        /// </summary>
#if UNITY_EDITOR
        public bool CheckForDuplicates = true;
#else
        public bool CheckForDuplicates = false;
#endif

        /// <summary>
        ///     Enable debug logging on this server instance.
        ///     Please set via RestServer.debugLog. Leaving this open for users that want to modify or have a separate RestServer implementation.
        /// </summary>
        public bool DebugLog {
            get => _logger.logEnabled;
            set => _logger.logEnabled = value;
        }

        #endregion

        #region Constructors

        public EndpointCollection(bool debugLog = false) {
            DebugLog = debugLog;
        }

        #endregion

        #region Register Endpoint HTTP

        /// <summary>Register a new endpoint this server should respond to.</summary>
        /// <param name="httpMethod">Method (GET, POST, ...) to respond to (required)</param>
        /// <param name="endpoint">Endpoint coordinate (required). Must start with "/".</param>
        /// <param name="requestHandler">
        ///     Method that handles incoming requests against this httpMethod/endpoint (required)
        ///     This method is executed inside the Thread of the Webserver and can't touch GameObjects in Unity,
        ///     because mostly they are not thread-safe.
        ///     To Interact with Unity, see <see cref="ThreadingHelper" />.
        /// </param>
        /// <param name="tag">Tag that can be used with DeleteByTag to easily delete a lot of endpoints generated by an algorithm.</param>
        /// <returns>Reference to the internal endpoint struct to validate which parameters have been set. Not modifiable.</returns>
        public Endpoint RegisterEndpoint(HttpMethod httpMethod, string endpoint, Action<RestRequest> requestHandler, object tag = null) {
            var codeLocation = DebugLogEndpoint("RegisterEndpoint", httpMethod, endpoint);

            var pathParams = PathParamHelper.ParseEndpoint(endpoint, out var regex);

            Endpoint e;
            if (regex != null) {
                e = new Endpoint {
                    Method = httpMethod,
                    EndpointRegex = regex,
                    PathParams = pathParams,
                    RequestHandler = requestHandler,
                    CodeLocation = codeLocation,
                    Tag = tag
                };
            } else {
                e = new Endpoint {
                    Method = httpMethod,
                    EndpointString = endpoint,
                    RequestHandler = requestHandler,
                    CodeLocation = codeLocation,
                    Tag = tag
                };
            }

            RegisterEndpointInternal(e);

            return e;
        }

        /// <summary>Register a new endpoint this server should respond to.</summary>
        /// <param name="httpMethod">Method (GET, POST, ...) to respond to (required)</param>
        /// <param name="endpointRegex">Endpoint coordinate (required). Note that the endpoint starts with "/" when matching.</param>
        /// <param name="requestHandler">
        ///     Method that handles incoming requests against this httpMethod/endpoint (required)
        ///     This method is executed inside the Thread of the Webserver and can't touch GameObjects in Unity,
        ///     because mostly they are not thread-safe.
        ///     To Interact with Unity, see <see cref="ThreadingHelper" />.
        /// </param>
        /// <param name="tag">Tag that can be used with DeleteByTag to easily delete a lot of endpoints generated by an algorithm.</param>
        /// <returns>Reference to the internal endpoint struct to validate which parameters have been set. Not modifiable.</returns>
        public Endpoint RegisterEndpoint(HttpMethod httpMethod, Regex endpointRegex, Action<RestRequest> requestHandler, object tag = null) {
            var codeLocation = DebugLogEndpoint("RegisterEndpoint", httpMethod, endpointRegex.ToString());
            var e = new Endpoint {
                Method = httpMethod,
                EndpointRegex = endpointRegex,
                RequestHandler = requestHandler,
                CodeLocation = codeLocation,
                Tag = tag
            };
            RegisterEndpointInternal(e);

            return e;
        }

        /// <summary>
        ///     Register the given endpoint against the internal collection.
        ///     Will <b>NOT</b> throw an exception if the endpoint has already been registered
        /// </summary>
        /// <param name="endpoint">The endpoint to register.</param>
        public void RegisterEndpoint(Endpoint endpoint) {
            var codeLocation = DebugLogEndpoint("RegisterEndpoint",
                endpoint.Method,
                endpoint.EndpointString != null ? endpoint.EndpointString : endpoint.EndpointRegex.ToString()
            );
            endpoint.CodeLocation = codeLocation;
            RegisterEndpointInternal(endpoint);
        }

        protected void RegisterEndpointInternal(Endpoint endpoint) {
            if (string.IsNullOrEmpty(endpoint.EndpointString) && endpoint.EndpointRegex == null) {
                throw new ArgumentNullException(nameof(endpoint.EndpointString) + " or " +
                                                nameof(endpoint.EndpointRegex)
                );
            }

            if (endpoint.RequestHandler == null && endpoint.WebSocketFrameHandler == null) {
                throw new ArgumentNullException(nameof(endpoint.RequestHandler));
            }

            if (endpoint.EndpointString != null && !endpoint.EndpointString.StartsWith("/")) {
                endpoint.EndpointString = "/" + endpoint.EndpointString;
            }

            // Check if endpoint already exists
            CheckForDuplicate(endpoint);
            // /Check

            _lock.EnterWriteLock();
            try {
                if (_handlers.ContainsKey(endpoint.Method)) {
                    _handlers[endpoint.Method].Add(endpoint);
                } else {
                    var temp = new List<Endpoint> { endpoint };
                    _handlers.Add(endpoint.Method, temp);
                }
            }
            finally {
                _lock.ExitWriteLock();
            }
        }

        #endregion

        #region Endpoint WebSocket

        /// <summary>
        /// Register a new endpoint path that has to be upgraded to websocket.
        /// </summary>
        /// <param name="endpoint">Path of the websocket endpoint</param>
        /// <param name="websocketFrameHandler">Handler that is called on every frame sent by the client</param>
        /// <param name="tag">Tag that can be used with DeleteByTag to easily delete a lot of endpoints generated by an algorithm.
        /// Used by StaticContentAutoEndpoint.</param>
        /// <returns>Returns an endpoint id that the server can use to send information to the client</returns>
        public WSEndpointId RegisterWebsocketEndpoint(string endpoint, Action<WebsocketMessage> websocketFrameHandler, object tag = null) {
            var id = WSEndpointId.NextId();
            var codeLocation = DebugLogEndpoint("RegisterWebsocketEndpoint", HttpMethod.GET, endpoint);

            RegisterEndpointInternal(new Endpoint {
                    Method = HttpMethod.GET,
                    EndpointString = endpoint,
                    WebSocketFrameHandler = websocketFrameHandler,
                    CodeLocation = codeLocation,
                    Tag = tag,
                    WsEndpointId = id
                }
            );
            return id;
        }

        /// <summary>
        /// Register a new endpoint path that has to be upgraded to websocket.
        /// </summary>
        /// <param name="endpointRegex">Path of the websocket endpoint. This uses Regex.IsMatch, so partial matches are possible. Use ^ and $ to match against
        /// the complete path.</param>
        /// <param name="endpoint">Path of the websocket endpoint</param>
        /// <param name="websocketFrameHandler">Handler that is called on every frame sent by the client</param>
        /// <param name="tag">Tag that can be used with DeleteByTag to easily delete a lot of endpoints generated by an algorithm.
        /// Used by StaticContentAutoEndpoint.</param>
        /// <returns>Returns an endpoint id that the server can use to send information to the client</returns>
        public WSEndpointId RegisterWebsocketEndpoint(Regex endpointRegex, Action<WebsocketMessage> websocketFrameHandler, object tag = null) {
            var id = WSEndpointId.NextId();
            var codeLocation = DebugLogEndpoint("RegisterWebsocketEndpoint", HttpMethod.GET, endpointRegex.ToString());

            RegisterEndpointInternal(new Endpoint {
                    Method = HttpMethod.GET,
                    EndpointRegex = endpointRegex,
                    WebSocketFrameHandler = websocketFrameHandler,
                    CodeLocation = codeLocation,
                    Tag = tag,
                    WsEndpointId = id
                }
            );
            return id;
        }

        #endregion

        #region Collection Methods

        /// <summary>
        ///     Removes the endpoint from the internal collection and returns it if an endpoint matching the parameters is found.
        /// </summary>
        /// <param name="method">HTTP method to search for.</param>
        /// <param name="url">The exact url string that was supplied when registering the endpoint</param>
        /// <returns>The found endpoint; null otherwise</returns>
        public Endpoint? RemoveEndpoint(HttpMethod method, string url) {
            DebugLogEndpoint("RemoveEndpoint", method, url);

            _lock.EnterUpgradeableReadLock();
            try {
                if (!_handlers.TryGetValue(method, out var endpoints)) {
                    return null;
                }

                for (var i = 0; i < endpoints.Count; i++) {
                    var endpoint = endpoints[i];
                    if (endpoint.EndpointString != url) {
                        continue;
                    }

                    _lock.EnterWriteLock();
                    try {
                        endpoints.RemoveAt(i);
                        return endpoint;
                    }
                    finally {
                        _lock.ExitWriteLock();
                    }
                }
            }
            finally {
                _lock.ExitUpgradeableReadLock();
            }

            return null;
        }

        /// <summary>
        ///     Removes the endpoint from the internal collection and returns it if an endpoint matching the parameters is found.
        /// </summary>
        /// <param name="method">HTTP method to search for.</param>
        /// <param name="url">The exact url string that was supplied when registering the endpoint</param>
        /// <returns>The found endpoint; null otherwise</returns>
        public Endpoint? RemoveEndpoint(HttpMethod method, Regex regex) {
            DebugLogEndpoint("RemoveEndpoint", method, regex.ToString());

            _lock.EnterUpgradeableReadLock();
            try {
                if (!_handlers.TryGetValue(method, out var endpoints)) {
                    return null;
                }

                for (var i = 0; i < endpoints.Count; i++) {
                    var endpoint = endpoints[i];
                    if (endpoint.EndpointRegex == null) {
                        continue;
                    }

                    if (endpoint.EndpointRegex.ToString() != regex.ToString()) {
                        continue;
                    }

                    _lock.EnterWriteLock();
                    try {
                        endpoints.RemoveAt(i);
                        return endpoint;
                    }
                    finally {
                        _lock.ExitWriteLock();
                    }
                }
            }
            finally {
                _lock.ExitUpgradeableReadLock();
            }

            return null;
        }
        
        /// <summary>
        ///     Find the second endpoint according to the parameters given. If there is none, return 404.
        /// </summary>
        /// <param name="method">HttpMethod</param>
        /// <param name="url">Url the endpoint corresponds to</param>
        /// <param name="ignoreTag">Tag to ignore</param>
        /// <returns>The found endpoint; null otherwise.</returns>
        public Endpoint? FindEndpoint(HttpMethod method, string url, object ignoreTag = null) {
            _lock.EnterReadLock();
            try {
                if (!_handlers.TryGetValue(method, out var endpoints)) {
                    return null;
                }

                if (ignoreTag == null) {
                    foreach (var endpoint in endpoints.Where(endpoint => endpoint.CanHandle(url))) {
                        return endpoint;
                    }
                } else {
                    foreach (var endpoint in endpoints.Where(endpoint => endpoint.CanHandle(url) && endpoint.Tag != ignoreTag)) {
                        return endpoint;
                    }   
                }
        
                return null;
            }
            finally {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        ///     Returns a cloned list of all endpoints responding to the given http method.
        /// </summary>
        /// <param name="httpMethod"></param>
        /// <returns>Cloned list of endpoints for the http method; null otherwise.</returns>
        public List<Endpoint> GetAllEndpoints(HttpMethod httpMethod) {
            _lock.EnterReadLock();
            try {
                return !_handlers.TryGetValue(httpMethod, out var endpoints) ? null : endpoints.ToList();
            }
            finally {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Delete all endpoints where the condition tag == deleteTag is fulfilled. This can be useful to easily delete all tags created by an algorithm.
        /// </summary>
        /// <param name="tag">Tag to delete, can't be null.</param>
        /// <returns>The number of endpoints that have been removed.</returns>
        public int DeleteByTag(object tag) {
            if (tag == null) {
                throw new ArgumentNullException(nameof(tag));
            }

            var deleteCount = 0;

            _lock.EnterWriteLock();
            try {
                foreach (var handler in _handlers) {
                    var endpoints = handler.Value;
                    var i = 0;
                    while (i < endpoints.Count) {
                        var ep = endpoints[i];
                        if (ep.Tag == tag) {
                            endpoints.RemoveAt(i);
                            deleteCount++;
                        } else {
                            i++;
                        }
                    }
                }
            }
            finally {
                _lock.ExitWriteLock();
            }

            return deleteCount;
        }

        /// <summary>
        /// Removes all registered endpoints (including websockets)
        /// </summary>
        public void Clear() {
            _lock.EnterWriteLock();
            try {
                _handlers.Clear();
            }
            finally {
                _lock.ExitWriteLock();
            }
        }

        #endregion

        #region Debugging Helpers

        private string DebugLogEndpoint(string method, HttpMethod httpMethod, string endpoint) {
#if UNITY_EDITOR
            var frame = new StackTrace().GetFrame(2);
            var type = frame.GetMethod().DeclaringType;
            var caller = frame.GetMethod().Name;
            var callingLocation = $"{type}.{caller}";
#else
            var callingLocation = "Only available in the editor";
#endif

            if (_logger.logEnabled) {
                _logger.Log($"{method} endpoint {httpMethod}:{endpoint} from {callingLocation}.");
            }

            return callingLocation;
        }


        /// <summary>
        /// Check if the given endpoint can be handled by another endpoint that is already registered. 
        /// </summary>
        /// <param name="endpoint">Endpoint to check</param>
        private void CheckForDuplicate(Endpoint endpoint) {
            if (!CheckForDuplicates) {
                return;
            }

            _logger.logEnabled = true;
            try {
                if (endpoint.EndpointString == null || !_handlers.ContainsKey(endpoint.Method)) {
                    return;
                }

                foreach (var handler in _handlers[endpoint.Method]) {
                    if (!handler.CanHandle(endpoint.EndpointString)) {
                        continue;
                    }

                    var otherEndpoint = handler.EndpointString != null ? handler.EndpointString : handler.EndpointRegex.ToString();
                    _logger.LogWarning($"There already exists an endpoint that can handle {endpoint.EndpointString}. The other endpoint {otherEndpoint} " +
                                       $"was registered from {endpoint.CodeLocation}.",
                        this
                    );
                }
            }
            finally {
                _logger.logEnabled = false;
            }
        }

        #endregion
    }
}